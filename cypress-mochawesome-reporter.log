start cypress-mochawesome-reporter 3.6.0
cwd: /Users/prasaddy/cypress_learning
cypress.json: {"configFile":"/Users/prasaddy/cypress_learning/cypress.config.js","env":{"__cypress_cucumber_preprocessor_dont_use_this_suite":{"isEventHandlersAttached":true}},"testingType":"e2e","reporter":"cypress-mochawesome-reporter","reporterOptions":{"reportDir":"/Users/prasaddy/cypress_learning/cypress/reports","charts":true,"reportPageTitle":"CypressReportBDD","embeddedScreenshots":true,"inlineAssets":true,"saveAllAttempts":false,"debug":true},"setupNodeEvents":"[Function setupNodeEvents]","specPattern":"cypress/integration/cucumber/**/*.feature","projectRoot":"/Users/prasaddy/cypress_learning","projectName":"cypress_learning","repoRoot":"/Users/prasaddy/cypress_learning","rawJson":{"reporter":"cypress-mochawesome-reporter","reporterOptions":{"reportDir":"cypress/reports","charts":true,"reportPageTitle":"CypressReportBDD","embeddedScreenshots":true,"inlineAssets":true,"saveAllAttempts":false,"debug":true},"e2e":{"setupNodeEvents":"[Function setupNodeEvents]","specPattern":"cypress/integration/cucumber/**/*.feature"},"setupNodeEvents":"[Function setupNodeEvents]","specPattern":"cypress/integration/cucumber/**/*.feature","envFile":{},"projectRoot":"/Users/prasaddy/cypress_learning","projectName":"cypress_learning","repoRoot":"/Users/prasaddy/cypress_learning"},"morgan":false,"isTextTerminal":true,"socketId":"4hp6k1ryvy","report":true,"animationDistanceThreshold":5,"arch":"x64","baseUrl":null,"blockHosts":null,"chromeWebSecurity":true,"clientCertificates":[],"defaultCommandTimeout":4000,"downloadsFolder":"/Users/prasaddy/cypress_learning/cypress/downloads","execTimeout":60000,"experimentalCspAllowList":false,"experimentalFetchPolyfill":false,"experimentalInteractiveRunEvents":false,"experimentalRunAllSpecs":false,"experimentalMemoryManagement":false,"experimentalModifyObstructiveThirdPartyCode":false,"experimentalSkipDomainInjection":null,"experimentalOriginDependencies":false,"experimentalSourceRewriting":false,"experimentalSingleTabRunMode":false,"experimentalStudio":false,"experimentalWebKitSupport":false,"fileServerFolder":"/Users/prasaddy/cypress_learning","fixturesFolder":"/Users/prasaddy/cypress_learning/cypress/fixtures","excludeSpecPattern":"*.hot-update.js","includeShadowDom":false,"keystrokeDelay":0,"modifyObstructiveCode":true,"numTestsKeptInMemory":0,"platform":"darwin","pageLoadTimeout":60000,"port":63449,"projectId":null,"redirectionLimit":20,"requestTimeout":5000,"resolvedNodePath":"/usr/local/Cellar/node/20.5.1/bin/node","resolvedNodeVersion":"20.5.1","responseTimeout":30000,"retries":{"runMode":0,"openMode":0},"screenshotOnRunFailure":true,"screenshotsFolder":"/Users/prasaddy/cypress_learning/cypress/screenshots","slowTestThreshold":10000,"scrollBehavior":"top","supportFile":"/Users/prasaddy/cypress_learning/cypress/support/e2e.js","supportFolder":"/Users/prasaddy/cypress_learning/cypress/support","taskTimeout":60000,"testIsolation":true,"trashAssetsBeforeRuns":true,"userAgent":null,"video":false,"videoCompression":false,"videosFolder":"/Users/prasaddy/cypress_learning/cypress/videos","viewportHeight":660,"viewportWidth":1000,"waitForAnimations":true,"watchForFileChanges":false,"additionalIgnorePattern":[],"autoOpen":false,"browsers":[{"name":"chrome","family":"chromium","channel":"stable","displayName":"Chrome","version":"116.0.5845.187","path":"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome","minSupportedVersion":64,"majorVersion":"116"},{"name":"firefox","family":"firefox","channel":"stable","displayName":"Firefox","version":"110.0.1","path":"/Applications/Firefox.app/Contents/MacOS/firefox","minSupportedVersion":86,"majorVersion":"110"},{"name":"electron","channel":"stable","family":"chromium","displayName":"Electron","version":"114.0.5735.289","path":"","majorVersion":114}],"clientRoute":"/__/","cypressBinaryRoot":"/Users/prasaddy/Library/Caches/Cypress/13.2.0/Cypress.app/Contents/Resources/app","devServerPublicPathRoute":"/__cypress/src","hosts":null,"isInteractive":true,"namespace":"__cypress","reporterRoute":"/__cypress/reporter","socketIoCookie":"__socket","socketIoRoute":"/__socket","version":"13.2.0","protocolEnabled":false,"hideCommandLog":false,"hideRunnerUi":false,"cypressEnv":"production","resolved":{"animationDistanceThreshold":{"value":5,"from":"default"},"arch":{"value":"x64","from":"default"},"baseUrl":{"value":null,"from":"default"},"blockHosts":{"value":null,"from":"default"},"chromeWebSecurity":{"value":true,"from":"default"},"clientCertificates":{"value":[],"from":"default"},"defaultCommandTimeout":{"value":4000,"from":"default"},"downloadsFolder":{"value":"cypress/downloads","from":"default"},"env":{"__cypress_cucumber_preprocessor_dont_use_this_suite":{"value":{"isEventHandlersAttached":true},"from":"plugin"}},"execTimeout":{"value":60000,"from":"default"},"experimentalCspAllowList":{"value":false,"from":"default"},"experimentalFetchPolyfill":{"value":false,"from":"default"},"experimentalInteractiveRunEvents":{"value":false,"from":"default"},"experimentalRunAllSpecs":{"value":false,"from":"default"},"experimentalMemoryManagement":{"value":false,"from":"default"},"experimentalModifyObstructiveThirdPartyCode":{"value":false,"from":"default"},"experimentalSkipDomainInjection":{"value":null,"from":"default"},"experimentalOriginDependencies":{"value":false,"from":"default"},"experimentalSourceRewriting":{"value":false,"from":"default"},"experimentalSingleTabRunMode":{"value":false,"from":"default"},"experimentalStudio":{"value":false,"from":"default"},"experimentalWebKitSupport":{"value":false,"from":"default"},"fileServerFolder":{"value":"","from":"default"},"fixturesFolder":{"value":"cypress/fixtures","from":"default"},"excludeSpecPattern":{"value":"*.hot-update.js","from":"default"},"includeShadowDom":{"value":false,"from":"default"},"keystrokeDelay":{"value":0,"from":"default"},"modifyObstructiveCode":{"value":true,"from":"default"},"numTestsKeptInMemory":{"value":0,"from":"config"},"platform":{"value":"darwin","from":"default"},"pageLoadTimeout":{"value":60000,"from":"default"},"port":{"value":null,"from":"default"},"projectId":{"value":null,"from":"default"},"redirectionLimit":{"value":20,"from":"default"},"reporter":{"value":"cypress-mochawesome-reporter","from":"config"},"reporterOptions":{"value":{"reportDir":"cypress/reports","charts":true,"reportPageTitle":"CypressReportBDD","embeddedScreenshots":true,"inlineAssets":true,"saveAllAttempts":false,"debug":true},"from":"config"},"requestTimeout":{"value":5000,"from":"default"},"resolvedNodePath":{"value":null,"from":"default"},"resolvedNodeVersion":{"value":null,"from":"default"},"responseTimeout":{"value":30000,"from":"default"},"retries":{"value":{"runMode":0,"openMode":0},"from":"default"},"screenshotOnRunFailure":{"value":true,"from":"default"},"screenshotsFolder":{"value":"cypress/screenshots","from":"default"},"slowTestThreshold":{"value":10000,"from":"default"},"scrollBehavior":{"value":"top","from":"default"},"supportFile":{"value":"cypress/support/e2e.{js,jsx,ts,tsx}","from":"default"},"supportFolder":{"value":false,"from":"default"},"taskTimeout":{"value":60000,"from":"default"},"testIsolation":{"value":true,"from":"default"},"trashAssetsBeforeRuns":{"value":true,"from":"default"},"userAgent":{"value":null,"from":"default"},"video":{"value":false,"from":"default"},"videoCompression":{"value":false,"from":"default"},"videosFolder":{"value":"cypress/videos","from":"default"},"viewportHeight":{"value":660,"from":"default"},"viewportWidth":{"value":1000,"from":"default"},"waitForAnimations":{"value":true,"from":"default"},"watchForFileChanges":{"value":false,"from":"config"},"specPattern":{"value":"cypress/integration/cucumber/**/*.feature","from":"config"},"browsers":{"value":[{"name":"chrome","family":"chromium","channel":"stable","displayName":"Chrome","version":"116.0.5845.187","path":"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome","minSupportedVersion":64,"majorVersion":"116","isHeadless":false,"isHeaded":true},{"name":"firefox","family":"firefox","channel":"stable","displayName":"Firefox","version":"110.0.1","path":"/Applications/Firefox.app/Contents/MacOS/firefox","minSupportedVersion":86,"majorVersion":"110"},{"name":"electron","channel":"stable","family":"chromium","displayName":"Electron","version":"114.0.5735.289","path":"","majorVersion":114}],"from":"runtime"},"hosts":{"value":null,"from":"default"},"isInteractive":{"value":true,"from":"default"},"configFile":{"value":"/Users/prasaddy/cypress_learning/cypress.config.js","from":"plugin"},"testingType":{"value":"e2e","from":"plugin"}},"remote":{"origin":"http://localhost:63449","strategy":"file","fileServer":"http://localhost:63450","domainName":"localhost","props":null},"browser":null,"specs":[],"proxyUrl":"http://localhost:63449","browserUrl":"http://localhost:63449/__/","reporterUrl":"http://localhost:63449/__cypress/reporter","proxyServer":"http://localhost:63449","state":{}}
simple config: {"jsonDir":"/Users/prasaddy/cypress_learning/cypress/reports/.jsons","reporterOptions":{"reportDir":"/Users/prasaddy/cypress_learning/cypress/reports","charts":true,"reportPageTitle":"CypressReportBDD","embeddedScreenshots":true,"inlineAssets":true,"saveAllAttempts":false,"debug":true},"screenshotsDir":"/Users/prasaddy/cypress_learning/cypress/screenshots","videosFolder":"/Users/prasaddy/cypress_learning/cypress/videos","outputDir":"/Users/prasaddy/cypress_learning/cypress/reports","removeJsonsFolderAfterMerge":true}
Remove output folder /Users/prasaddy/cypress_learning/cypress/reports
Start generate report process
Read and merge jsons from "/Users/prasaddy/cypress_learning/cypress/reports/.jsons"
report before enhance: {"stats":{"suites":1,"tests":2,"passes":2,"pending":0,"failures":0,"testsRegistered":2,"passPercent":100,"pendingPercent":0,"other":0,"hasOther":false,"skipped":0,"hasSkipped":false,"start":"2023-09-17T01:03:36.102Z","end":"2023-09-17T01:03:48.754Z","duration":12652},"results":[{"uuid":"2860d545-a2ad-438e-bcd8-97ff9fb0a717","title":"","fullFile":"cypress/integration/cucumber/tests/features/LoginFeature/LoginTest.feature","file":"cypress/integration/cucumber/tests/features/LoginFeature/LoginTest.feature","beforeHooks":[],"afterHooks":[],"tests":[],"suites":[{"uuid":"00227d33-22d4-4fd2-adeb-6f943411655b","title":"Login page validation of the application","fullFile":"","file":"","beforeHooks":[],"afterHooks":[],"tests":[{"title":"As a user, after providing valid credentials. User land's on HRM welcome page.","fullTitle":"Login page validation of the application As a user, after providing valid credentials. User land's on HRM welcome page.","timedOut":null,"duration":3917,"state":"passed","speed":"fast","pass":true,"fail":false,"pending":false,"context":null,"code":"var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\ntaskTestCaseStarted(context, {\n    id: testCaseStartedId,\n    testCaseId,\n    attempt: attempt++,\n    timestamp: (0, messages_1.createTimestamp)(),\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        const testStepId = getTestStepId({\n            context,\n            pickleId: pickle.id,\n            hookIdOrPickleStepId: hook.id,\n        });\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            const start = (0, messages_1.createTimestamp)();\n            internalProperties.currentStepStartedAt = start;\n            taskTestStepStarted(context, {\n                testStepId,\n                testCaseStartedId,\n                timestamp: start,\n            });\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            (0, cypress_1.runStepWithLogGroup)({\n                fn: () => registry.runHook(this, hook),\n                keyword: hook.keyword,\n                text: hook.tags,\n            });\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_1.createTimestamp)();\n            taskTestStepFinished(context, {\n                testStepId,\n                testCaseStartedId,\n                testStepResult: {\n                    status: messages.TestStepResultStatus.PASSED,\n                    duration: (0, messages_1.duration)(start, end),\n                },\n                timestamp: end,\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const testStepId = getTestStepId({\n            context,\n            pickleId: pickle.id,\n            hookIdOrPickleStepId: pickleStep.id,\n        });\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            const start = (0, messages_1.createTimestamp)();\n            internalProperties.currentStep = { pickleStep };\n            internalProperties.currentStepStartedAt = start;\n            taskTestStepStarted(context, {\n                testStepId,\n                testCaseStartedId,\n                timestamp: start,\n            });\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const beforeStepHooks = registry.resolveBeforeStepHooks(tags);\n            const afterStepHooks = registry.resolveAfterStepHooks(tags);\n            const options = {\n                pickle,\n                pickleStep,\n                gherkinDocument,\n                testCaseStartedId,\n                testStepId,\n            };\n            const beforeHooksChain = beforeStepHooks.reduce((chain, beforeStepHook) => {\n                return chain.then(() => (0, cypress_1.runStepWithLogGroup)({\n                    keyword: \"BeforeStep\",\n                    text: beforeStepHook.tags,\n                    fn: () => registry.runStepHook(this, beforeStepHook, options),\n                }));\n            }, cy.wrap({}, { log: false }));\n            return beforeHooksChain.then(() => {\n                try {\n                    return (0, cypress_1.runStepWithLogGroup)({\n                        keyword: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                        argument,\n                        text,\n                        fn: () => registry.runStepDefininition(this, text, argument),\n                    }).then((result) => {\n                        return afterStepHooks\n                            .reverse()\n                            .reduce((chain, afterStepHook) => {\n                            return chain.then(() => (0, cypress_1.runStepWithLogGroup)({\n                                keyword: \"AfterStep\",\n                                text: afterStepHook.tags,\n                                fn: () => registry.runStepHook(this, afterStepHook, options),\n                            }));\n                        }, cy.wrap({}, { log: false }))\n                            .then(() => {\n                            return { start, result };\n                        });\n                    });\n                }\n                catch (e) {\n                    if (e instanceof registry_1.MissingDefinitionError) {\n                        throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            });\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_1.createTimestamp)();\n            if (result === \"pending\" || result === \"skipped\") {\n                if (result === \"pending\") {\n                    taskTestStepFinished(context, {\n                        testStepId,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.PENDING,\n                            duration: (0, messages_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    });\n                }\n                else {\n                    taskTestStepFinished(context, {\n                        testStepId,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.SKIPPED,\n                            duration: (0, messages_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    });\n                }\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const hookIdOrPickleStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    const testStepId = getTestStepId({\n                        context,\n                        pickleId: pickle.id,\n                        hookIdOrPickleStepId,\n                    });\n                    taskTestStepStarted(context, {\n                        testStepId,\n                        testCaseStartedId,\n                        timestamp: (0, messages_1.createTimestamp)(),\n                    });\n                    taskTestStepFinished(context, {\n                        testStepId,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.SKIPPED,\n                            duration: {\n                                seconds: 0,\n                                nanos: 0,\n                            },\n                        },\n                        timestamp: (0, messages_1.createTimestamp)(),\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                cy.then(() => this.skip());\n            }\n            else {\n                taskTestStepFinished(context, {\n                    testStepId,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: messages.TestStepResultStatus.PASSED,\n                        duration: (0, messages_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}","err":{},"uuid":"9e1209a2-4829-4dc0-8028-e5ed29e3e9ed","parentUUID":"00227d33-22d4-4fd2-adeb-6f943411655b","isHook":false,"skipped":false},{"title":"As a user, after providing invalid credentials. User should see error.","fullTitle":"Login page validation of the application As a user, after providing invalid credentials. User should see error.","timedOut":null,"duration":5927,"state":"passed","speed":"medium","pass":true,"fail":false,"pending":false,"context":null,"code":"var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\ntaskTestCaseStarted(context, {\n    id: testCaseStartedId,\n    testCaseId,\n    attempt: attempt++,\n    timestamp: (0, messages_1.createTimestamp)(),\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        const testStepId = getTestStepId({\n            context,\n            pickleId: pickle.id,\n            hookIdOrPickleStepId: hook.id,\n        });\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            const start = (0, messages_1.createTimestamp)();\n            internalProperties.currentStepStartedAt = start;\n            taskTestStepStarted(context, {\n                testStepId,\n                testCaseStartedId,\n                timestamp: start,\n            });\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            (0, cypress_1.runStepWithLogGroup)({\n                fn: () => registry.runHook(this, hook),\n                keyword: hook.keyword,\n                text: hook.tags,\n            });\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_1.createTimestamp)();\n            taskTestStepFinished(context, {\n                testStepId,\n                testCaseStartedId,\n                testStepResult: {\n                    status: messages.TestStepResultStatus.PASSED,\n                    duration: (0, messages_1.duration)(start, end),\n                },\n                timestamp: end,\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const testStepId = getTestStepId({\n            context,\n            pickleId: pickle.id,\n            hookIdOrPickleStepId: pickleStep.id,\n        });\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            const start = (0, messages_1.createTimestamp)();\n            internalProperties.currentStep = { pickleStep };\n            internalProperties.currentStepStartedAt = start;\n            taskTestStepStarted(context, {\n                testStepId,\n                testCaseStartedId,\n                timestamp: start,\n            });\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const beforeStepHooks = registry.resolveBeforeStepHooks(tags);\n            const afterStepHooks = registry.resolveAfterStepHooks(tags);\n            const options = {\n                pickle,\n                pickleStep,\n                gherkinDocument,\n                testCaseStartedId,\n                testStepId,\n            };\n            const beforeHooksChain = beforeStepHooks.reduce((chain, beforeStepHook) => {\n                return chain.then(() => (0, cypress_1.runStepWithLogGroup)({\n                    keyword: \"BeforeStep\",\n                    text: beforeStepHook.tags,\n                    fn: () => registry.runStepHook(this, beforeStepHook, options),\n                }));\n            }, cy.wrap({}, { log: false }));\n            return beforeHooksChain.then(() => {\n                try {\n                    return (0, cypress_1.runStepWithLogGroup)({\n                        keyword: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                        argument,\n                        text,\n                        fn: () => registry.runStepDefininition(this, text, argument),\n                    }).then((result) => {\n                        return afterStepHooks\n                            .reverse()\n                            .reduce((chain, afterStepHook) => {\n                            return chain.then(() => (0, cypress_1.runStepWithLogGroup)({\n                                keyword: \"AfterStep\",\n                                text: afterStepHook.tags,\n                                fn: () => registry.runStepHook(this, afterStepHook, options),\n                            }));\n                        }, cy.wrap({}, { log: false }))\n                            .then(() => {\n                            return { start, result };\n                        });\n                    });\n                }\n                catch (e) {\n                    if (e instanceof registry_1.MissingDefinitionError) {\n                        throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            });\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_1.createTimestamp)();\n            if (result === \"pending\" || result === \"skipped\") {\n                if (result === \"pending\") {\n                    taskTestStepFinished(context, {\n                        testStepId,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.PENDING,\n                            duration: (0, messages_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    });\n                }\n                else {\n                    taskTestStepFinished(context, {\n                        testStepId,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.SKIPPED,\n                            duration: (0, messages_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    });\n                }\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const hookIdOrPickleStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    const testStepId = getTestStepId({\n                        context,\n                        pickleId: pickle.id,\n                        hookIdOrPickleStepId,\n                    });\n                    taskTestStepStarted(context, {\n                        testStepId,\n                        testCaseStartedId,\n                        timestamp: (0, messages_1.createTimestamp)(),\n                    });\n                    taskTestStepFinished(context, {\n                        testStepId,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.SKIPPED,\n                            duration: {\n                                seconds: 0,\n                                nanos: 0,\n                            },\n                        },\n                        timestamp: (0, messages_1.createTimestamp)(),\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                cy.then(() => this.skip());\n            }\n            else {\n                taskTestStepFinished(context, {\n                    testStepId,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: messages.TestStepResultStatus.PASSED,\n                        duration: (0, messages_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}","err":{},"uuid":"6ae1ac0e-8e24-4269-8a7b-3e6e2342e51a","parentUUID":"00227d33-22d4-4fd2-adeb-6f943411655b","isHook":false,"skipped":false}],"suites":[],"passes":["9e1209a2-4829-4dc0-8028-e5ed29e3e9ed","6ae1ac0e-8e24-4269-8a7b-3e6e2342e51a"],"failures":[],"pending":[],"skipped":[],"duration":9844,"root":false,"rootEmpty":false,"_timeout":2000}],"passes":[],"failures":[],"pending":[],"skipped":[],"duration":0,"root":true,"rootEmpty":true,"_timeout":2000}],"meta":{"mocha":{"version":"7.0.1"},"mochawesome":{"options":{"quiet":false,"reportFilename":"mochawesome","saveHtml":false,"saveJson":true,"consoleReporter":"spec","useInlineDiffs":false,"code":true},"version":"7.1.3"},"marge":{"options":{"reportDir":"cypress/reports/.jsons","charts":true,"reportPageTitle":"CypressReportBDD","embeddedScreenshots":true,"inlineAssets":true,"saveAllAttempts":false,"debug":true,"overwrite":false,"html":false,"json":true},"version":"6.2.0"}}}
Enhance report
baseFolder: cypress/integration/cucumber/tests/features/LoginFeature
attach media for test "Login page validation of the application As a user, after providing valid credentials. User land's on HRM welcome page."
no context
attach media for test "Login page validation of the application As a user, after providing invalid credentials. User should see error."
no context
report after enhance: {"stats":{"suites":1,"tests":2,"passes":2,"pending":0,"failures":0,"testsRegistered":2,"passPercent":100,"pendingPercent":0,"other":0,"hasOther":false,"skipped":0,"hasSkipped":false,"start":"2023-09-17T01:03:36.102Z","end":"2023-09-17T01:03:48.754Z","duration":12652},"results":[{"uuid":"2860d545-a2ad-438e-bcd8-97ff9fb0a717","title":"","fullFile":"cypress/integration/cucumber/tests/features/LoginFeature/LoginTest.feature","file":"cypress/integration/cucumber/tests/features/LoginFeature/LoginTest.feature","beforeHooks":[],"afterHooks":[],"tests":[],"suites":[{"uuid":"00227d33-22d4-4fd2-adeb-6f943411655b","title":"Login page validation of the application","fullFile":"cypress/integration/cucumber/tests/features/LoginFeature/LoginTest.feature","file":"cypress/integration/cucumber/tests/features/LoginFeature/LoginTest.feature","beforeHooks":[],"afterHooks":[],"tests":[{"title":"As a user, after providing valid credentials. User land's on HRM welcome page.","fullTitle":"Login page validation of the application As a user, after providing valid credentials. User land's on HRM welcome page.","timedOut":null,"duration":3917,"state":"passed","speed":"fast","pass":true,"fail":false,"pending":false,"context":null,"code":"var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\ntaskTestCaseStarted(context, {\n    id: testCaseStartedId,\n    testCaseId,\n    attempt: attempt++,\n    timestamp: (0, messages_1.createTimestamp)(),\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        const testStepId = getTestStepId({\n            context,\n            pickleId: pickle.id,\n            hookIdOrPickleStepId: hook.id,\n        });\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            const start = (0, messages_1.createTimestamp)();\n            internalProperties.currentStepStartedAt = start;\n            taskTestStepStarted(context, {\n                testStepId,\n                testCaseStartedId,\n                timestamp: start,\n            });\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            (0, cypress_1.runStepWithLogGroup)({\n                fn: () => registry.runHook(this, hook),\n                keyword: hook.keyword,\n                text: hook.tags,\n            });\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_1.createTimestamp)();\n            taskTestStepFinished(context, {\n                testStepId,\n                testCaseStartedId,\n                testStepResult: {\n                    status: messages.TestStepResultStatus.PASSED,\n                    duration: (0, messages_1.duration)(start, end),\n                },\n                timestamp: end,\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const testStepId = getTestStepId({\n            context,\n            pickleId: pickle.id,\n            hookIdOrPickleStepId: pickleStep.id,\n        });\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            const start = (0, messages_1.createTimestamp)();\n            internalProperties.currentStep = { pickleStep };\n            internalProperties.currentStepStartedAt = start;\n            taskTestStepStarted(context, {\n                testStepId,\n                testCaseStartedId,\n                timestamp: start,\n            });\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const beforeStepHooks = registry.resolveBeforeStepHooks(tags);\n            const afterStepHooks = registry.resolveAfterStepHooks(tags);\n            const options = {\n                pickle,\n                pickleStep,\n                gherkinDocument,\n                testCaseStartedId,\n                testStepId,\n            };\n            const beforeHooksChain = beforeStepHooks.reduce((chain, beforeStepHook) => {\n                return chain.then(() => (0, cypress_1.runStepWithLogGroup)({\n                    keyword: \"BeforeStep\",\n                    text: beforeStepHook.tags,\n                    fn: () => registry.runStepHook(this, beforeStepHook, options),\n                }));\n            }, cy.wrap({}, { log: false }));\n            return beforeHooksChain.then(() => {\n                try {\n                    return (0, cypress_1.runStepWithLogGroup)({\n                        keyword: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                        argument,\n                        text,\n                        fn: () => registry.runStepDefininition(this, text, argument),\n                    }).then((result) => {\n                        return afterStepHooks\n                            .reverse()\n                            .reduce((chain, afterStepHook) => {\n                            return chain.then(() => (0, cypress_1.runStepWithLogGroup)({\n                                keyword: \"AfterStep\",\n                                text: afterStepHook.tags,\n                                fn: () => registry.runStepHook(this, afterStepHook, options),\n                            }));\n                        }, cy.wrap({}, { log: false }))\n                            .then(() => {\n                            return { start, result };\n                        });\n                    });\n                }\n                catch (e) {\n                    if (e instanceof registry_1.MissingDefinitionError) {\n                        throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            });\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_1.createTimestamp)();\n            if (result === \"pending\" || result === \"skipped\") {\n                if (result === \"pending\") {\n                    taskTestStepFinished(context, {\n                        testStepId,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.PENDING,\n                            duration: (0, messages_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    });\n                }\n                else {\n                    taskTestStepFinished(context, {\n                        testStepId,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.SKIPPED,\n                            duration: (0, messages_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    });\n                }\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const hookIdOrPickleStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    const testStepId = getTestStepId({\n                        context,\n                        pickleId: pickle.id,\n                        hookIdOrPickleStepId,\n                    });\n                    taskTestStepStarted(context, {\n                        testStepId,\n                        testCaseStartedId,\n                        timestamp: (0, messages_1.createTimestamp)(),\n                    });\n                    taskTestStepFinished(context, {\n                        testStepId,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.SKIPPED,\n                            duration: {\n                                seconds: 0,\n                                nanos: 0,\n                            },\n                        },\n                        timestamp: (0, messages_1.createTimestamp)(),\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                cy.then(() => this.skip());\n            }\n            else {\n                taskTestStepFinished(context, {\n                    testStepId,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: messages.TestStepResultStatus.PASSED,\n                        duration: (0, messages_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}","err":{},"uuid":"9e1209a2-4829-4dc0-8028-e5ed29e3e9ed","parentUUID":"00227d33-22d4-4fd2-adeb-6f943411655b","isHook":false,"skipped":false},{"title":"As a user, after providing invalid credentials. User should see error.","fullTitle":"Login page validation of the application As a user, after providing invalid credentials. User should see error.","timedOut":null,"duration":5927,"state":"passed","speed":"medium","pass":true,"fail":false,"pending":false,"context":null,"code":"var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\ntaskTestCaseStarted(context, {\n    id: testCaseStartedId,\n    testCaseId,\n    attempt: attempt++,\n    timestamp: (0, messages_1.createTimestamp)(),\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        const testStepId = getTestStepId({\n            context,\n            pickleId: pickle.id,\n            hookIdOrPickleStepId: hook.id,\n        });\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            const start = (0, messages_1.createTimestamp)();\n            internalProperties.currentStepStartedAt = start;\n            taskTestStepStarted(context, {\n                testStepId,\n                testCaseStartedId,\n                timestamp: start,\n            });\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            (0, cypress_1.runStepWithLogGroup)({\n                fn: () => registry.runHook(this, hook),\n                keyword: hook.keyword,\n                text: hook.tags,\n            });\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_1.createTimestamp)();\n            taskTestStepFinished(context, {\n                testStepId,\n                testCaseStartedId,\n                testStepResult: {\n                    status: messages.TestStepResultStatus.PASSED,\n                    duration: (0, messages_1.duration)(start, end),\n                },\n                timestamp: end,\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const testStepId = getTestStepId({\n            context,\n            pickleId: pickle.id,\n            hookIdOrPickleStepId: pickleStep.id,\n        });\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            const start = (0, messages_1.createTimestamp)();\n            internalProperties.currentStep = { pickleStep };\n            internalProperties.currentStepStartedAt = start;\n            taskTestStepStarted(context, {\n                testStepId,\n                testCaseStartedId,\n                timestamp: start,\n            });\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const beforeStepHooks = registry.resolveBeforeStepHooks(tags);\n            const afterStepHooks = registry.resolveAfterStepHooks(tags);\n            const options = {\n                pickle,\n                pickleStep,\n                gherkinDocument,\n                testCaseStartedId,\n                testStepId,\n            };\n            const beforeHooksChain = beforeStepHooks.reduce((chain, beforeStepHook) => {\n                return chain.then(() => (0, cypress_1.runStepWithLogGroup)({\n                    keyword: \"BeforeStep\",\n                    text: beforeStepHook.tags,\n                    fn: () => registry.runStepHook(this, beforeStepHook, options),\n                }));\n            }, cy.wrap({}, { log: false }));\n            return beforeHooksChain.then(() => {\n                try {\n                    return (0, cypress_1.runStepWithLogGroup)({\n                        keyword: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                        argument,\n                        text,\n                        fn: () => registry.runStepDefininition(this, text, argument),\n                    }).then((result) => {\n                        return afterStepHooks\n                            .reverse()\n                            .reduce((chain, afterStepHook) => {\n                            return chain.then(() => (0, cypress_1.runStepWithLogGroup)({\n                                keyword: \"AfterStep\",\n                                text: afterStepHook.tags,\n                                fn: () => registry.runStepHook(this, afterStepHook, options),\n                            }));\n                        }, cy.wrap({}, { log: false }))\n                            .then(() => {\n                            return { start, result };\n                        });\n                    });\n                }\n                catch (e) {\n                    if (e instanceof registry_1.MissingDefinitionError) {\n                        throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            });\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_1.createTimestamp)();\n            if (result === \"pending\" || result === \"skipped\") {\n                if (result === \"pending\") {\n                    taskTestStepFinished(context, {\n                        testStepId,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.PENDING,\n                            duration: (0, messages_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    });\n                }\n                else {\n                    taskTestStepFinished(context, {\n                        testStepId,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.SKIPPED,\n                            duration: (0, messages_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    });\n                }\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const hookIdOrPickleStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    const testStepId = getTestStepId({\n                        context,\n                        pickleId: pickle.id,\n                        hookIdOrPickleStepId,\n                    });\n                    taskTestStepStarted(context, {\n                        testStepId,\n                        testCaseStartedId,\n                        timestamp: (0, messages_1.createTimestamp)(),\n                    });\n                    taskTestStepFinished(context, {\n                        testStepId,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.SKIPPED,\n                            duration: {\n                                seconds: 0,\n                                nanos: 0,\n                            },\n                        },\n                        timestamp: (0, messages_1.createTimestamp)(),\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                cy.then(() => this.skip());\n            }\n            else {\n                taskTestStepFinished(context, {\n                    testStepId,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: messages.TestStepResultStatus.PASSED,\n                        duration: (0, messages_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}","err":{},"uuid":"6ae1ac0e-8e24-4269-8a7b-3e6e2342e51a","parentUUID":"00227d33-22d4-4fd2-adeb-6f943411655b","isHook":false,"skipped":false}],"suites":[],"passes":["9e1209a2-4829-4dc0-8028-e5ed29e3e9ed","6ae1ac0e-8e24-4269-8a7b-3e6e2342e51a"],"failures":[],"pending":[],"skipped":[],"duration":9844,"root":false,"rootEmpty":false,"_timeout":2000}],"passes":[],"failures":[],"pending":[],"skipped":[],"duration":0,"root":true,"rootEmpty":true,"_timeout":2000}],"meta":{"mocha":{"version":"7.0.1"},"mochawesome":{"options":{"quiet":false,"reportFilename":"mochawesome","saveHtml":false,"saveJson":true,"consoleReporter":"spec","useInlineDiffs":false,"code":true},"version":"7.1.3"},"marge":{"options":{"reportDir":"cypress/reports/.jsons","charts":true,"reportPageTitle":"CypressReportBDD","embeddedScreenshots":true,"inlineAssets":true,"saveAllAttempts":false,"debug":true,"overwrite":false,"html":false,"json":true},"version":"6.2.0"}}}
Create HTML report
HTML result: ["/Users/prasaddy/cypress_learning/cypress/reports/index.html",null]
HTML report successfully created!
/Users/prasaddy/cypress_learning/cypress/reports/index.html
done
